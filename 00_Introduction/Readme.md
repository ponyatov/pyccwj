# 00: Карта путешествия

Я решил отправиться в путешествие по написанию компилятора. В прошлом я написал
несколько
[ассемблеров](https://github.com/DoctorWkt/pdp7-unix/blob/master/tools/as7) и
[простой компилятор](https://github.com/DoctorWkt/h-compiler) для языка без
типов. Но я никогда не писал компилятор, который может компилировать сам себя.
Вот куда я направляюсь в этом путешествии.

Как часть процесса, я собираюсь написать свою работу так, чтобы другие могли
следовать по ней. Это также поможет мне прояснить мои мысли и идеи. Надеюсь, что
и вы, и я сочтем это полезным!

## Цели путешествия

Вот мои цели и не-цели для путешествия:
* Написать самокомпилирующийся компилятор. Я думаю, что только если компилятор
  может скомпилировать себя, он может назвать себя настоящим компилятором.
* Ориентироваться как минимум на одну реальную аппаратную платформу. Я видел
  несколько компиляторов, которые генерируют код для гипотетических машин. Я
  хочу, чтобы мой компилятор работал на реальном оборудовании. Также, если
  возможно, я хочу написать компилятор, чтобы он мог поддерживать несколько
  бэкэндов для разных аппаратных платформ.
  * *В этом пункте мы наоборот отойдем от оригинала, и будем делать компилятор
    под виртуальную машину (интерпретатор байт-кода)*, чтобы пользователь мог без
    переделок запускать и его, и скомпилированные программы на любом
    оборудовании (Одурино, IoT, и вот это вот все)
* Практика важнее теории. Есть много исследований в области компиляторов. Я хочу
  начать с абсолютного нуля в этом путешествии, поэтому я буду стремиться к
  практическому подходу, а не к теоретическому. Тем не менее, будут моменты,
  когда мне нужно будет описать (и реализовать) некоторые теоретические вещи.
* Следуй принципу KISS: keep it simple, stupid! Я определенно собираюсь
  использовать здесь принцип Кена Томпсона: «Если есть сомнения, используйте
  дубовое решение».
* Сделайте много маленьких шагов, чтобы достичь конечной цели. Я разделю
  путешествие на множество простых шагов, вместо того чтобы делать большие
  прыжки. Это сделает каждое новое дополнение к компилятору легко усваиваемым
  небольшим кусочком.

## Целевой язык

Выбор целевого языка затруднен. Если я выберу язык высокого уровня, такой как
Python, Go и т.д., мне придется реализовать целую кучу библиотек и классов,
поскольку они встроены в язык.

Я мог бы написать компилятор для такого языка, как Lisp, но сделать это слишком легко.

Вместо этого я вернулся к старым основам и собираюсь написать компилятор для
подмножества C, достаточный для того, чтобы компилятор мог скомпилировать сам
себя.

*Чтобы получить результат быстрее, bootstrap-компилятор мы напишем на Python*

C является всего лишь одним шагом верх по уровню языка от ассемблера (для
некоторого подмножества C, а не
[C'18](https://en.wikipedia.org/wiki/C18_(C_standard_revision))), и это поможет
сделать задачу компиляции кода C в ассемблер несколько проще. Ну, и C мне тоже
нравится.

## Основы работы компилятора

![](parsing_steps.png)

1. входной код на языке высокого уровня (у нас это Си)
1. лексический анализ (разпознавание токенов)
1. грамматический анализ (распознавание синтаксисеских стуктур)
1. семантический анализ (понимание смысла кода)
1. перевод смысла в в язык низкого уровня (ассемблер)
1. низкоуровневый вывод (машинный код, байткод)

* [Лексический анализ](https://en.wikipedia.org/wiki/Lexical_analysis)
  распознает лексические элементы. В некоторых языках `=` отличается от `==`,
  поэтому вы не можете просто прочитать один `=`. Мы называем эти лексические
  элементы **токенами**.

* [Парсер](https://en.wikipedia.org/wiki/Parsing) входного языка распознает
  **синтаксис** и структурные элементы ввода и проверяет, что они соответствуют
  грамматике языка. Например, ваш язык может иметь такую структуру управления:
```
if (x < 23) {
        print("x is smaller than 23\n");
}
```
но на другом языке вы можете написать:
```
if (x < 23):
    print("x is smaller than 23\n")
```
Это также этап, где компилятор может обнаруживать синтаксические ошибки,
например, если точка с запятой отсутствует в конце первого оператора печати.

* Выполнение [семантического анализа](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))
  входных данных, то есть понимание смысла входных данных. Это на самом деле
  отличается от распознавания синтаксиса и структуры. Например, на английском
  языке предложение может иметь форму `<субъект> <глагол> <adjective> <объект>`.
  Следующие два предложения имеют одинаковую структуру, но совершенно разное
  значение:

```
David ate lovely bananas.
Jennifer hates green tomatoes.
```

* [Трансляция](https://en.wikipedia.org/wiki/Code_generation_(compiler)) смысла
  конструкции входного языка на другой язык. Здесь мы преобразуем входные данные
  по частям в язык более низкого уровня.

## Ресурсы

В интернете много ресурсов по разработке компиляторов. Вот те, на которые я буду смотреть:

### Книги

* \[dragon book\] [Компиляторы. Принципы, технологии и инструментарий](https://www.ozon.ru/context/detail/id/148627197/) **второе издание**<br>
Лам Моника С., Сети Рави, Ульман Джеффри Д., Ахо Альфред В.
* \[tiger book\] https://www.cs.princeton.edu/~appel/modern/ [PDF](https://doc.lagout.org/programmation/C/Modern%20Compiler%20Implementation%20in%20C%20%5BAppel%201997-12-13%5D.pdf)<br>
Andrew W. Appel

### Учебные ресурсы

Если вы хотите начать с чтения книг, статей по компиляторам и освоения
существующих инструментов , я очень рекомендую этот список:

[Модерируемый список потрясающих ресурсов по компиляторам, интерпретаторам и средам исполнения](https://github.com/aalhour/awesome-compilers) Ахмада Альхура

### Существующие облегченные компиляторы

Поскольку я собираюсь создать свой собственный компилятор, я планирую искать
идеи в других компиляторах и, возможно, также позаимствовать часть их кода. Вот
те, на которые я смотрю:
* [SubC](http://www.t3x.org/subc/) by Nils M Holm
* [Swieros C Compiler](https://github.com/rswier/swieros/blob/master/root/bin/c.c) by Robert Swierczek
* [fbcc](https://github.com/DoctorWkt/fbcc) by Fabrice Bellard
* [tcc](https://bellard.org/tcc/), также by Fabrice Bellard и другие
* [catc](https://github.com/yui0/catc) by Yuichiro Nakada
* [amacc](https://github.com/jserv/amacc) by Jim Huang
* [Small C](https://en.wikipedia.org/wiki/Small-C) by Ron Cain, James E. Hendrix, и его клоны, сделанные другими авторами

В частности, я буду использовать большинство идей и часть кода из компилятора SubC.

## Настройка среды разработки

Предполагая, что вы хотите отправиться в это путешествие вместе со мной, вот что
вам нужно. Я собираюсь использовать среду разработки Linux, поэтому скачайте и
настройте свою любимую систему Linux: я использую Lubuntu 18.04. *Debian
GNU/Linux 9*

Я собираюсь компилировать для двух аппаратных платформ: Intel x86-64 и 32-битной
ARM. Я буду использовать ПК с Lubuntu 18.04 в качестве цели Intel и Raspberry Pi
с Raspbian в качестве цели ARM.
*Для переносимости кода для встраиваемых систем будет использоваться
интерпретатор байткода (виртуальная машина), написанная на ANSI'C*

На платформе Intel нам понадобится существующий компилятор Си. Итак, установите
этот пакет (я даю команды Ubuntu/Debian):
```
$ sudo apt install build-essential
```

Если для ванильной системы Linux требуются дополнительные инструменты, дайте мне знать.

Проще всего, клонируйте копию этого репозитория GitHub, и запустите скрипт установки,
он включает установку всех необходимых пакетов и отдельного окружения Python:
```
$ cd ~
$ git clone -o gh https://github.com/ponyatov/pyccwj
$ cd ~/pyccwj
~/pyccwj$ make install
```

## Следующий шаг

В следующей части нашего пути написания компилятора мы начнем с кода для
сканирования входного файла и нахождения токенов, которые являются лексическими
элементами нашего языка.

[раздел 01](../01_Scanner/Readme.md): Введение в лексическое сканирование
