# Раздел 00: Карта путешествия

Я решил отправиться в путешествие по написанию компилятора. В прошлом я написал
несколько
[ассемблеров](https://github.com/DoctorWkt/pdp7-unix/blob/master/tools/as7) и
[простой компилятор](https://github.com/DoctorWkt/h-compiler) для языка без
типов. Но я никогда не писал компилятор, который может компилировать сам себя.
Вот куда я направляюсь в этом путешествии.

Как часть процесса, я собираюсь написать свою работу так, чтобы другие могли
следовать по ней. Это также поможет мне прояснить мои мысли и идеи. Надеюсь, что
и вы, и я сочтем это полезным!

## Цели путешествия

Вот мои цели и не-цели для путешествия:
* Написать самокомпилирующийся компилятор. Я думаю, что только если компилятор
  может скомпилировать себя, он может назвать себя настоящим компилятором.
* Ориентироваться как минимум на одну реальную аппаратную платформу. Я видел
  несколько компиляторов, которые генерируют код для гипотетических машин. Я
  хочу, чтобы мой компилятор работал на реальном оборудовании. Также, если
  возможно, я хочу написать компилятор, чтобы он мог поддерживать несколько
  бэкэндов для разных аппаратных платформ.
  * *В этом пункте мы наоборот отойдем от оригинала, и будем делать компилятор
    под виртуальную машину (интерпретатор байт-кода)*, чтобы пользователь мог без
    переделок запускать и его, и скомпилированные программы на любом
    оборудовании (Одурино, IoT, и вот это вот все)
* Практика важнее теории. Есть много исследований в области компиляторов. Я хочу
  начать с абсолютного нуля в этом путешествии, поэтому я буду стремиться к
  практическому подходу, а не к теоретическому. Тем не менее, будут моменты,
  когда мне нужно будет описать (и реализовать) некоторые теоретические вещи.
* Следуй принципу KISS: keep it simple, stupid! Я определенно собираюсь
  использовать здесь принцип Кена Томпсона: «Если есть сомнения, используйте
  дубовое решение».
* Сделайте много маленьких шагов, чтобы достичь конечной цели. Я разделю
  путешествие на множество простых шагов, вместо того чтобы делать большие
  прыжки. Это сделает каждое новое дополнение к компилятору легко усваиваемым
  небольшим кусочком.

## Целевой язык

Выбор целевого языка затруднен. Если я выберу язык высокого уровня, такой как
Python, Go и т.д., мне придется реализовать целую кучу библиотек и классов,
поскольку они встроены в язык.

Я мог бы написать компилятор для такого языка, как Lisp, но сделать это слишком легко.

Вместо этого я вернулся к старым основам и собираюсь написать компилятор для
подмножества C, достаточный для того, чтобы компилятор мог скомпилировать сам
себя.

*Чтобы получить результат быстрее, bootstrap-компилятор мы напишем на Python*

C является всего лишь одним шагом верх по уровню языка от ассемблера (для
некоторого подмножества C, а не
[C'18](https://en.wikipedia.org/wiki/C18_(C_standard_revision))), и это поможет
сделать задачу компиляции кода C в ассемблер несколько проще. Ну, и C мне тоже
нравится.

## Основы работы компилятора

![](parsing_steps.png)

1. входной код на языке высокого уровня (у нас это Си)
1. лексический анализ (разпознавание токенов)
1. грамматический анализ (распознавание синтаксисеских стуктур)
1. семантический анализ (понимание смысла кода)
1. перевод смысла в в язык низкого уровня (ассемблер)
1. низкоуровневый вывод (машинный код, байткод)

* [Лексический анализ](https://en.wikipedia.org/wiki/Lexical_analysis)
  распознает лексические элементы. В некоторых языках `=` отличается от `==`,
  поэтому вы не можете просто прочитать один `=`. Мы называем эти лексические
  элементы **токенами**.

* [Парсер](https://en.wikipedia.org/wiki/Parsing) входного языка распознает
  **синтаксис** и структурные элементы ввода и проверяет, что они соответствуют
  грамматике языка. Например, ваш язык может иметь такую структуру управления:
```
if (x < 23) {
        print("x is smaller than 23\n");
}
```
но на другом языке вы можете написать:
```
if (x < 23):
    print("x is smaller than 23\n")
```
Это также этап, где компилятор может обнаруживать синтаксические ошибки,
например, если точка с запятой отсутствует в конце первого оператора печати.

* Выполнение [семантического анализа](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))
  входных данных, то есть понимание смысла входных данных. Это на самом деле
  отличается от распознавания синтаксиса и структуры. Например, на английском
  языке предложение может иметь форму `<субъект> <глагол> <adjective> <объект>`.
  Следующие два предложения имеют одинаковую структуру, но совершенно разное
  значение:

```
David ate lovely bananas.
Jennifer hates green tomatoes.
```

* [Трансляция](https://en.wikipedia.org/wiki/Code_generation_(compiler)) смысла
  конструкции входного языка на другой язык. Здесь мы преобразуем входные данные
  по частям в язык более низкого уровня.

