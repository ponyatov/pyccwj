# Раздел 00: Карта путешествия

Я решил отправиться в путешествие по написанию компилятора. В прошлом я написал
несколько
[ассемблеров](https://github.com/DoctorWkt/pdp7-unix/blob/master/tools/as7) и
[простой компилятор](https://github.com/DoctorWkt/h-compiler) для языка без
типов. Но я никогда не писал компилятор, который может компилировать сам себя.
Вот куда я направляюсь в этом путешествии.

Как часть процесса, я собираюсь написать свою работу так, чтобы другие могли
следовать по ней. Это также поможет мне прояснить мои мысли и идеи. Надеюсь, что
и вы, и я сочтем это полезным!

## Цели путешествия

Вот мои цели и не-цели для путешествия:
* Написать самокомпилирующийся компилятор. Я думаю, что только если компилятор
  может скомпилировать себя, он может назвать себя настоящим компилятором.
* Ориентироваться как минимум на одну реальную аппаратную платформу. Я видел
  несколько компиляторов, которые генерируют код для гипотетических машин. Я
  хочу, чтобы мой компилятор работал на реальном оборудовании. Также, если
  возможно, я хочу написать компилятор, чтобы он мог поддерживать несколько
  бэкэндов для разных аппаратных платформ.
  * *В этом пункте мы наоборот отойдем от оригинала, и будем делать компилятор
    под виртуальную машину (интерпретатор байт-кода)*, чтобы пользователь мог без
    переделок запускать и его, и скомпилированные программы на любом
    оборудовании (Одурино, IoT, и вот это вот все)
* Практика важнее теории. Есть много исследований в области компиляторов. Я хочу
  начать с абсолютного нуля в этом путешествии, поэтому я буду стремиться к
  практическому подходу, а не к теоретическому. Тем не менее, будут моменты,
  когда мне нужно будет описать (и реализовать) некоторые теоретические вещи.
* Следуй принципу KISS: keep it simple, stupid! Я определенно собираюсь
  использовать здесь принцип Кена Томпсона: «Если есть сомнения, используйте
  дубовое решение».
* Сделайте много маленьких шагов, чтобы достичь конечной цели. Я разделю
  путешествие на множество простых шагов, вместо того чтобы делать большие
  прыжки. Это сделает каждое новое дополнение к компилятору легко усваиваемым
  небольшим кусочком.

## Целевой язык

Выбор целевого языка затруднен. Если я выберу язык высокого уровня, такой как
Python, Go и т.д., мне придется реализовать целую кучу библиотек и классов,
поскольку они встроены в язык.

Я мог бы написать компилятор для такого языка, как Lisp, но сделать это слишком легко.

Вместо этого я вернулся к старым основам и собираюсь написать компилятор для
подмножества C, достаточный для того, чтобы компилятор мог скомпилировать сам
себя.

*Чтобы получить результат быстрее, bootstrap-компилятор мы напишем на Python*

C является всего лишь одним шагом верх по уровню языка от ассемблера (для
некоторого подмножества C, а не
[C'18](https://en.wikipedia.org/wiki/C18_(C_standard_revision))), и это поможет
сделать задачу компиляции кода C в ассемблер несколько проще. Ну, и C мне тоже
нравится.

## Основы работы компилятора

![](parsing_steps.png)
